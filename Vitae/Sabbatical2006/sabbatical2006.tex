\documentclass{article}

\usepackage{fullpage}
\usepackage{hyperref}

\newcommand{\duphref}[1]{\href{#1}{#1}}
\newcommand{\term}[1]{\textbf{#1}}
\newcommand{\person}[1]{\textbf{#1}}

\title{Sabbatical Proposal for Interim \& Spring 2007}
\author{Jeremy D.\ Frens}
\date{}

\begin{document}

\maketitle

\section*{Eligibility}

\begin{itemize}
\item I am an Assistant Professor.
\item I am currently in my sixth year at Calvin as Assistant Professor.
\item My preliminary research is described in the proposal below.
\item My department chair approves (and has strongly encouraged) my sabbatical.
\end{itemize}

\section*{The Project}

\emph{I propose to use incremental development to teach programming languages.}

\subsection*{Programming-Languages Interpreter Project}

A programming languages course---like the one I teach each spring (CS~214), required by all computer-science majors---explores the different types of programming languages and the different features of these langauges.  Typically, there are two general ways to approach the programming assignments.  The first way is to expose the students to several different langauges.  Not only do the syntaxes of the languages differ greatly, but often the meaning behind similar instructions can be very different.  Learning a couple different languages demonstrates these differences to the students.

Another approach (the one I favor) asks the students to \emph{implement} their own languages; this is done by writing an interpreter~\cite{eopl}.  An interpreter is a program that reads in \emph{another} program and executes the commands in that other program as it is read in.  Interpreters are relatively easy to write, and they can be changed in very small ways to have a huge impact on the way they execute the same code.  Students see how the decisions behind the language are implemented and the impact that they have.

An interpreter usually consists of three phases: a lexer, a parser, and the interpreter itself; one phase feeds into the next.  Traditionally, these three phases are completed as programming projects in three separate stages.  As is often the case, students fall behind in the course, and so by the end of the course, they may have very little of the interpreter itself written while they know a lot about the parser and even more about the lexer.  It is preferrable by far that a student have an equal understanding of each of the three phases.

\subsection*{Incremental Development}

Incremental development is a process for developing software where a complete program is built at each stage of development.  Features are added one at a time, until the desired program is built.  One way to implement incremental development is to use test-driven development (TDD)~\cite{tdd}.

Test-driven development is an approach to writing code where \term{unit tests} for a computation are written before the computation is implemented.  If I write a library to compute square roots, I first write five or six unit tests which test various inputs (e.g., ``I expect to get $5$ when I compute the square root of $25$'', ``I expect an error when I try to compute the square root of $-8$'').  These tests fail because the computation code is not written yet; however, I know that the tests are active because I see them fail.  I then write computation code for computing the square root; I am finished writing computation code when all of my tests pass.

Since the tests are relatively small, they are executed \emph{very} frequently.  Old tests make sure that I do not break any old code while adding new features.

TDD also uses a process known as \term{refactoring} to change existing code without changing the observed behavior.  For example, I can change the name of a variable without changing the behavior of my code.  In mathematics, this is equivalent to changing from $f(x)=x^2$ to $f(y)=y^2$; computationally this makes no difference, but to the reader (i.e., programmer) it can be very significant.  Renaming a variable is one of the simplest refactorings; many refactorings use other refactorings as substeps and can be quite complicated.

Refactoring is used to modify the code so that new features can be added.  The code is orginally written for \emph{only} the requested features, and some of the code may be too specific and rigid for new features.  Refactoring generalizes existing code so that new features can be added easily.  Then, once new features are added and they pass their unit tests, refactoring eliminates the redundancies that were introduced by adding the new features.

Refactoring and unit testing provide the groundwork for incremental development.  A working application is built at each stage of development.  Refactoring allows for new, small features to be added; unit tests make sure that nothing breaks (especially during refactoring).

\subsection*{Incremental Development of an Interpreter}

My project is to develop the resources (i.e., lab manuals, software) needed by students to write an interpreter in a programming-languages course using incremental development.  These materials would be tested that same semester in Calvin's programming-languages course.

There is a strong, growing group of computer-science educators who feel that unit testing should be added to an undergraduate education.  Wick et al.~\cite{eauclaire} presents a comprehensive approach to using unit testing throughout the curriculum at the University of Wisconsin, Eau Claire.  More than a few other schools are doing the same (as summarized by Jones~\cite{jones}).

Refactoring, on the other hand, is rarely mentioned in educational settings, and when mentioned, it is an advanced topic for students.  Students in a programming languages course have the skill set to do the refactorings and to understand them; the issue seems to be the time spent learning to refactor.  However, I see refactoring itself as a programming-languages issue, and it \emph{should} be taught in a programming-languages course.

The main benefit of incremental development of an interpreter is that students will work on a complete interpreter from the first week until the end of the project.  Each week, new features will be added, which will require the students to change each phase of their interpreter.  The first couple interpreters will be very simple, but even halfway through the semester, students will be working with the fundamental aspects of an interpreter.  So a student who falls so far behind that he gets only half of the project done will still see a fair amount of each of the three phases---the knowledge such a student \emph{should} have.

From my prelimiary work, it appears that an incremental approach also makes the connection between the different stages of a program much clearer.  Instead of seeing three phases which superficially plug into each other to make an interpreter, students see the interpreter as a whole which can be divided into three conceptual stages.  The reason why one feature is implemented in one phase and not another becomes much clearer when the students see the whole interpreter.

Another benefit of this approach is that it allows for instructional flexibility.  Each student might be asked to implement a different feature as a final project.  Honors students can pick their own features they would like to implement.  Instructors could change the order each time the course is taught.  Because of this flexibility, there are particular challenges to writing educational materials.  In particular, adding Feature~A before Feature~B may require certain steps which are very different that the steps followed if Feature~B is added before Feature~A.

The tools used in TDD are a practical benefit.  The tools we would use (e.g., Eclipse for editing code and for easy refactoring, JUnit for testing) are used in industry, and the techniques learned are applicable on any programming project.

At the end of my sabbatical, I expect two tangible products:
\begin{itemize}
\item A lab manual for TDD instruction and incremental development of an interpreter.
\item Support software for incremental development of an interpreter.
\end{itemize}
I have already developed software that supports the unit testing of lexers and parser (see attached curriculum vitae).  Other libraries are needed to support interpreter development.

I also anticipate writing papers about my work for SIGCSE (an annual computer-science education conference) and for OOPSLA (an annual object-oriented programming conference).

My work will also give me a solid foundation for writing an NSF CCLI (Course, Curriculum, and Laboratory Improvement) grant to carry my work further.  I would like a student or two to help collect data about the effectiveness of this approach.

  % A detailed description of the project. Depending on the nature of the project, this should include the goals, major theses, outline, and methods of the project. The description should also include the place of the project in the particular area of study; i.e., why it should be done and how the proposed study will contribute to an understanding of the issues. The description should include reference to the literature that is relevant to the project.

\section*{Expected Benefits}

  % 5. Expected benefits of the project to the applicant, the profession, and the college.

For myself and for the computer-science profession, my project will have a direct pedagogical benefit: instruction materials for a programming-languages course.  I would certainly use the materials myself, and I would try to publish the materials for the larger community.  My work should also demonstrate to the profession the effectiveness of using incremental development in a programming-languages course.  Since few have recognized this opportunity, the field is rich for pedagogical studies.

In terms of my long-term research goals, I have become very interested in TDD and software-development processes that use TDD (Extreme Programming in particular).  One of the aspects of TDD that intrigues me is how concepts from programming languages impact TDD techniques.  For example, many refactorings have a strong theoretical basis in programming-language theory.  I think there are some technical articles to be written in this area based on the things I learn from this sabbatical and my externship.

The college will benefit by the papers and instructional materials that I produce, demonstrating the Calvin faculty have a committment to hard research as well as to teaching.  It will also benefit our computer-science students since they will have all of the advantages my approach offers.

\section*{Qualifications}

I am quite familiar with TDD and incremental development.  I have used TDD in several programming projects of my own, including one public project, an interpreter for a language called No Latte (see attached vitae).  I have also created my own library for testing lexers and parsers (see attached vitae).  I have six significant personal projects which were developed using TDD.

I also plan to get hands-on experience with TDD as part of an externship at Atomic Object, a local company in Grand Rapids.  Atomic Object uses incremental development and TDD.  This externship will be done the Fall semester before this sabbatical.

In terms of the pedogical aspects of my project, I have rewritten the lab manual for our introductory programming course (see attached vitae).  I focus primarily on the testing aspects of TDD, because refactoring is a little too advanced for beginning programmers.

Finally, I have already tried out this intructional approach with a student who took a compiler course as an independent study.  We used incremental development to build a complete compiler each week of the semester; since a compiler is similar to an interpreter, this was good practice for this particular project.  The student and I have written a paper (see attached) which we submitted to SIGCSE~2006, an annual conference on Computer Science education.

  % A statement of the qualifications of the applicant for pursuing the proposed project. This should include prior preparation for work in the area of the proposed study, a list of grants received or pending during the last five years, and the results of previous sabbaticals or leaves of absence, including a copy of the previous sabbatical report, if any. A curriculum vitae, which may be in a condensed form that includes all relevant information, shall be attached.

\newpage
\section*{Work Schedule}

\begin{itemize}
  \item \textbf{Interim 2007}
    \begin{itemize}
    \item Try out several different ways of adding features to an interpreter.
    \item Find a workable sequence of features for the spring semester.
    \end{itemize}
  \item \textbf{Spring 2007}
    \begin{itemize}
    \item Prepare labs and support libraries for programming-languages course.
    \item Determine how to write a lab manual which deals with different sequences of features.
    \item Write a more comprehensive lab manual based on student feedback and with different sequences of features.
    \item Begin an NSF CCLI grant for further study of this approach, including student help in collecting and analyzing feedback.
    \end{itemize}
  \item \textbf{Summer 2007}
    \begin{itemize}
    \item Finish grant.
    \item Write sabbatical reports.
    \end{itemize}
\end{itemize}

  % 6. A work schedule and itinerary projected for the duration of the leave.

\section*{Financial Budget}

Since I will be proto-typing my lab materials in the programming-languages course here at Calvin during my sabbatical, I will want my office.  (I will not need it for the fall semester during my externship at Atomic Object.)  I will not require any other funds or resources.

% 7. A financial budget for the period of leave. This should be an estimate of expenses including support services provided by the college. Include an explanation of the expenses and indicate the source of funds for meeting expenses beyond the salary provided by the college. The applicant should report on what steps have been taken to seek outside support for the sabbatical. Approval of the proposal does not constitute approval of the project budget beyond the salary.

\section*{Remuneration Statement}

I will not accept other remunerative employment without consent of the college, and I agree to the college policy on remuneration received from any product of my sabbatical leave.

\begin{thebibliography}{99}
  \bibitem{tdd} Astels, D.  \textit{Test-Driven Development: A Practical Guide}.  Prentice Hall PTR: Upper Saddle River, NJ, 2003.
  \bibitem{eopl} Friedman, D., Wand, M., and Haynes, C.~T.  \textit{Essentials of Programming Languages}, 2e.  The MIT Press: Cambridge, MA, 2001.
  \bibitem{jones} Jones, C.~G. 2004. Test-driven development goes to school. J. Comput. Small Coll. 20, 1 (Oct. 2004), 220-231. 
  \bibitem{eauclaire} Wick, M., Stevenson, D., and Wagner, P. 2005. Using testing and JUnit across the curriculum. In Proceedings of the 36th SIGCSE Technical Symposium on Computer Science Education (St. Louis, Missouri, USA, February 23--27, 2005). SIGCSE '05. ACM Press, New York, NY, 236-240. http://doi.acm.org/10.1145/1047344.1047427.
\end{thebibliography}

\end{document}

